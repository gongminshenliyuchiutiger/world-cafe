<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>佇註解輪流站計時系統</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Font Awesome CDN -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha512-DTOQO9RWCH3ppGqcWaEA1BIZOC6xxalwEsw9c2QQeAIftl+Vegovlnee1c9QX4TctnWMn13TZye+giMm8e2LwA==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;500;700&display=swap');

        html {
            scroll-behavior: smooth; /* 平滑滾動效果 */
            /* Default light mode colors */
            --bg-primary: #f9f7f7;
            --bg-secondary: #e3f2fd;
            --bg-card: white;
            --bg-card-secondary: #f9fafb; /* gray-50 */
            --bg-card-active: #eff6ff; /* blue-50 */
            --bg-card-break: #fff7ed; /* orange-50 */
            --bg-card-completed: #f0fdf4; /* green-50 */
            --text-primary: #1f2937; /* gray-800 */
            --text-secondary: #6b7280; /* gray-500 */
            --text-title: #1e3a8a; /* blue-800 */
            --text-button: white;
            --border-primary: #e5e7eb; /* gray-200 */
            --border-secondary: #d1d5db; /* gray-300 */
            --border-active: #bfdbfe; /* blue-300 */
            --border-break: #fed7aa; /* orange-300 */
            --border-completed: #bbf7d0; /* green-300 */
            --input-bg: white;
            --input-border: #d1d5db;
            --input-focus-border: #3b82f6;
            --input-focus-ring: rgba(59, 130, 246, 0.3);
            --svg-base: #e5e7eb; /* gray-200 */
            --footer-bg: #1f2937; /* gray-800 */
            --footer-text: white;
            --switch-bg-inactive: #ccc;
            --switch-bg-active: #3b82f6;
            --fullscreen-bg: rgba(255, 255, 255, 0.7);
            --fullscreen-hover-bg: rgba(243, 244, 246, 0.9);
            --fullscreen-icon: #374151; /* gray-700 */
            --darkmode-icon: #6b7280; /* gray-500 */
            --darkmode-icon-hover: #1f2937; /* gray-800 */
            --darkmode-toggle-bg: rgba(255, 255, 255, 0.7);
            --darkmode-toggle-hover-bg: rgba(243, 244, 246, 0.9);
        }

        html.dark {
            /* Dark mode colors */
            --bg-primary: #111827; /* gray-900 */
            --bg-secondary: #1f2937; /* gray-800 */
            --bg-card: #374151; /* gray-700 */
            --bg-card-secondary: #4b5563; /* gray-600 */
            --bg-card-active: #1e3a8a; /* dark blue */
            --bg-card-break: #7c2d12; /* dark orange */
            --bg-card-completed: #064e3b; /* dark green */
            --text-primary: #f3f4f6; /* gray-100 */
            --text-secondary: #9ca3af; /* gray-400 */
            --text-title: #60a5fa; /* blue-400 */
            --text-button: white;
            --border-primary: #4b5563; /* gray-600 */
            --border-secondary: #6b7280; /* gray-500 */
            --border-active: #3b82f6; /* blue-500 */
            --border-break: #f97316; /* orange-500 */
            --border-completed: #22c55e; /* green-500 */
            --input-bg: #4b5563; /* gray-600 */
            --input-border: #6b7280; /* gray-500 */
            --input-focus-border: #60a5fa; /* blue-400 */
            --input-focus-ring: rgba(96, 165, 250, 0.4);
            --svg-base: #4b5563; /* gray-600 */
            --footer-bg: #000000; /* black */
            --footer-text: #d1d5db; /* gray-300 */
            --switch-bg-inactive: #4b5563; /* gray-600 */
            --switch-bg-active: #60a5fa; /* blue-400 */
            --fullscreen-bg: rgba(55, 65, 81, 0.7); /* gray-700 */
            --fullscreen-hover-bg: rgba(75, 85, 99, 0.9); /* gray-600 */
            --fullscreen-icon: #d1d5db; /* gray-300 */
            --darkmode-icon: #9ca3af; /* gray-400 */
            --darkmode-icon-hover: #f3f4f6; /* gray-100 */
            --darkmode-toggle-bg: rgba(55, 65, 81, 0.7); /* gray-700 */
            --darkmode-toggle-hover-bg: rgba(75, 85, 99, 0.9); /* gray-600 */
        }

        body {
            font-family: 'Noto Sans TC', sans-serif;
            background: linear-gradient(135deg, var(--bg-primary) 0%, var(--bg-secondary) 100%);
            color: var(--text-primary);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            transition: background 0.3s ease, color 0.3s ease;
        }

        .content {
            flex: 1;
        }

        .timer-circle {
            position: relative;
            width: 280px;
            height: 280px;
            transition: width 0.3s ease, height 0.3s ease;
        }

        .timer-circle svg {
            transform: rotate(-90deg);
            width: 100%;
            height: 100%;
        }
        .timer-circle circle#baseCircle {
             stroke: var(--svg-base);
             transition: stroke 0.3s ease;
        }
        .timer-circle circle#timerCircle {
            /* Apply the gradient stroke */
            stroke: url(#progressGradient);
            transition: stroke-dashoffset 0.1s linear; /* Only transition offset */
             stroke-dasharray: 100 100;
             stroke-dashoffset: 100;
        }

        .notification {
            animation: slideIn 0.5s ease-out forwards;
            color: white;
        }

        @keyframes slideIn {
            from { transform: translateY(-100%); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .btn {
             padding: 0.75rem 1.5rem;
             border-radius: 0.5rem;
             font-weight: 500;
             transition: all 0.3s ease;
             border: 1px solid transparent;
             cursor: pointer;
             display: inline-flex;
             align-items: center;
             justify-content: center;
             gap: 0.5rem;
        }
        .btn:disabled { cursor: not-allowed; opacity: 0.6; }

        .btn-primary {
            background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%);
            color: var(--text-button);
        }
        .btn-primary:hover:not(:disabled) { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3); }
        .btn-primary:disabled { background: linear-gradient(135deg, #93c5fd 0%, #60a5fa 100%); }
        html.dark .btn-primary { background: linear-gradient(135deg, #60a5fa 0%, #3b82f6 100%); }
        html.dark .btn-primary:hover:not(:disabled) { box-shadow: 0 4px 12px rgba(96, 165, 250, 0.4); }
        html.dark .btn-primary:disabled { background: linear-gradient(135deg, #374151 0%, #4b5563 100%); opacity: 0.5; }

        .btn-secondary {
            background: linear-gradient(135deg, #f97316 0%, #ea580c 100%);
             color: var(--text-button);
        }
        .btn-secondary:hover:not(:disabled) { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(249, 115, 22, 0.3); }
        .btn-secondary:disabled { background: linear-gradient(135deg, #fdba74 0%, #fb923c 100%); }
        html.dark .btn-secondary { background: linear-gradient(135deg, #fb923c 0%, #f97316 100%); }
        html.dark .btn-secondary:hover:not(:disabled) { box-shadow: 0 4px 12px rgba(251, 146, 60, 0.4); }
        html.dark .btn-secondary:disabled { background: linear-gradient(135deg, #4b5563 0%, #52525b 100%); opacity: 0.5; }

        .btn-outline-pause {
             border-color: #3b82f6;
             color: #3b82f6;
             background-color: var(--bg-card);
        }
        .btn-outline-pause:hover:not(:disabled) { background-color: rgba(59, 130, 246, 0.1); }
        .btn-outline-pause:disabled { border-color: var(--border-secondary); color: var(--text-secondary); background-color: var(--bg-card); }
        html.dark .btn-outline-pause { border-color: #60a5fa; color: #60a5fa; background-color: var(--bg-card); }
        html.dark .btn-outline-pause:hover:not(:disabled) { background-color: rgba(96, 165, 250, 0.15); }
        html.dark .btn-outline-pause:disabled { border-color: var(--border-secondary); color: var(--text-secondary); background-color: var(--bg-card); }

        .btn-outline-reset {
             border-color: var(--border-secondary);
             color: var(--text-secondary);
             background-color: var(--bg-card);
        }
        .btn-outline-reset:hover:not(:disabled) { background-color: rgba(156, 163, 175, 0.1); }
        .btn-outline-reset:disabled { border-color: #d1d5db; color: #9ca3af; background-color: var(--bg-card); }
        html.dark .btn-outline-reset { border-color: var(--border-secondary); color: var(--text-secondary); background-color: var(--bg-card); }
        html.dark .btn-outline-reset:hover:not(:disabled) { background-color: rgba(107, 114, 128, 0.2); }
        html.dark .btn-outline-reset:disabled { border-color: #4b5563; color: #6b7280; background-color: var(--bg-card); }

        .card {
            background-color: var(--bg-card);
            color: var(--text-primary);
            border: 1px solid var(--border-primary);
            transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
        }
        .table-card {
            transition: all 0.3s ease;
            background-color: var(--bg-card-secondary);
            border: 1px solid var(--border-primary);
            color: var(--text-primary);
            cursor: pointer; /* All cards are potentially clickable */
        }
        .table-card h3 { color: var(--text-primary); transition: color 0.3s ease; }
        .table-card p { color: var(--text-secondary); transition: color 0.3s ease; }
        .table-card .status-indicator { background-color: #9ca3af; transition: background-color 0.3s ease; }

        /* Slightly dim completed cards, but keep hover effect */
        .table-card.completed {
             opacity: 0.8;
        }
        .table-card:hover {
             transform: translateY(-3px);
             box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
        }
        html.dark .table-card:hover { box-shadow: 0 10px 25px rgba(255, 255, 255, 0.05); }


        /* Active Round Card */
        .table-card.active-round { background-color: var(--bg-card-active); border-color: var(--border-active); opacity: 1; }
        .table-card.active-round .status-indicator { background-color: #3b82f6; }
        html.dark .table-card.active-round .status-indicator { background-color: #60a5fa; }

        /* Active Break Card */
        .table-card.active-break { background-color: var(--bg-card-break); border-color: var(--border-break); opacity: 1; }
        .table-card.active-break h3 { color: #c2410c; }
        html.dark .table-card.active-break h3 { color: #fb923c; }
        .table-card.active-break .status-indicator { background-color: #f97316; }
        html.dark .table-card.active-break .status-indicator { background-color: #fb923c; }

        /* Completed Card Styling */
        .table-card.completed { background-color: var(--bg-card-completed); border-color: var(--border-completed); }
        .table-card.completed .status-indicator { background-color: #16a34a; }
        html.dark .table-card.completed .status-indicator { background-color: #4ade80; }


        .sound-switch { position: relative; display: inline-block; width: 50px; height: 24px; }
        .sound-switch input { opacity: 0; width: 0; height: 0; }
        .sound-slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: var(--switch-bg-inactive); transition: .4s; border-radius: 24px; }
        .sound-slider:before { position: absolute; content: ""; height: 16px; width: 16px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .sound-slider { background-color: var(--switch-bg-active); }
        input:checked + .sound-slider:before { transform: translateX(26px); }

        footer {
            margin-top: auto;
            background-color: var(--footer-bg);
            color: var(--footer-text);
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        .styled-input {
            text-align: center;
            padding: 0.5rem 0.75rem;
            border: 1px solid var(--input-border);
            border-radius: 0.5rem;
            appearance: textfield;
            background-color: var(--input-bg);
            color: var(--text-primary);
            transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
        }
        .styled-input:focus {
             outline: none;
             border-color: var(--input-focus-border);
             box-shadow: 0 0 0 2px var(--input-focus-ring);
        }
        .styled-input::-webkit-outer-spin-button,
        .styled-input::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
        .styled-input[type=number] { -moz-appearance: textfield; }

        .time-input {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            align-items: end;
        }
        .time-input input {
             width: 100%;
             composes: styled-input;
        }
        .time-input > div {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .time-input-label {
            text-align: center;
            font-size: 0.75rem;
            line-height: 1rem;
            color: var(--text-secondary);
            margin-top: 2px;
            transition: color 0.3s ease;
        }

        .settings-label { display: flex; align-items: center; gap: 0.5rem; }
        .settings-label i { color: var(--text-secondary); width: 1.1em; text-align: center; transition: color 0.3s ease; }
        .settings-label span { color: var(--text-primary); transition: color 0.3s ease; }

        #testSound { background-color: var(--bg-card-secondary); color: var(--text-primary); transition: background-color 0.3s ease, color 0.3s ease; }
        #testSound:hover { background-color: var(--border-primary); }
        html.dark #testSound { background-color: var(--bg-card-secondary); color: var(--text-primary); }
        html.dark #testSound:hover { background-color: var(--border-primary); }

        select.styled-input { /* Apply base styles to select */
             /* Adjust padding if needed */
             padding: 0.5rem 0.75rem;
        }
        html.dark select option { background-color: var(--input-bg); color: var(--text-primary); }


        #timer-block { position: relative; }
        #timer-top-controls {
            position: absolute;
            top: 1rem;
            right: 1rem;
            display: flex;
            gap: 0.5rem;
            z-index: 10;
         }
         #fullscreenBtn {
             background: var(--fullscreen-bg);
             border-radius: 50%;
             width: 2.5rem;
             height: 2.5rem;
             display: flex;
             align-items: center;
             justify-content: center;
             color: var(--fullscreen-icon);
             border: 1px solid var(--border-primary);
             transition: all 0.2s ease;
             cursor: pointer;
             padding: 0;
         }
         #fullscreenBtn:hover {
             background: var(--fullscreen-hover-bg);
             color: var(--darkmode-icon-hover);
         }
         #fullscreenBtn i {
             font-size: 1.1rem;
             line-height: 1;
         }

        #mainDarkModeToggle {
             position: absolute;
             top: 1rem;
             right: 1rem;
             background: var(--darkmode-toggle-bg);
             border-radius: 50%;
             width: 2.5rem;
             height: 2.5rem;
             display: flex;
             align-items: center;
             justify-content: center;
             color: var(--darkmode-icon);
             border: 1px solid var(--border-primary);
             transition: all 0.2s ease;
             cursor: pointer;
             padding: 0;
             z-index: 20;
         }
          #mainDarkModeToggle:hover {
             background: var(--darkmode-toggle-hover-bg);
             color: var(--darkmode-icon-hover);
         }
          #mainDarkModeToggle i {
             font-size: 1.1rem;
             line-height: 1;
         }

        #timer-block:fullscreen {
            width: 100%; height: 100%;
            background-color: var(--bg-card);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            padding: 2rem; overflow-y: auto;
         }
        #timer-block:fullscreen .timer-circle { width: 60vh; height: 60vh; max-width: 600px; max-height: 600px; }
        #timer-block:fullscreen #timeDisplay { font-size: 10vmax; color: var(--text-primary); }
        #timer-block:fullscreen #timeDescription { font-size: 2vmax; margin-top: 1rem; color: var(--text-secondary); }
        #timer-block:fullscreen h2 { font-size: 3.5vmax; color: var(--text-primary); }
        #timer-block:fullscreen #statusText { font-size: 2.5vmax; margin-bottom: 1rem; color: var(--text-secondary); }
        #timer-block:fullscreen .btn { padding: 1rem 2rem; font-size: 1.25rem; border-radius: 0.75rem; }
        #timer-block:fullscreen #timer-top-controls {
            position: fixed;
            top: 1.5rem;
            right: 1.5rem;
         }

        html.dark #timer-block:fullscreen { background-color: var(--bg-primary); }

        #timer-block:-webkit-full-screen { background-color: var(--bg-card); display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 2rem; width: 100%; height: 100%; }
        #timer-block:-moz-full-screen { background-color: var(--bg-card); display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 2rem; width: 100%; height: 100%; }
        #timer-block:-ms-fullscreen { background-color: var(--bg-card); display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 2rem; width: 100%; height: 100%; }
        html.dark #timer-block:-webkit-full-screen,
        html.dark #timer-block:-moz-full-screen,
        html.dark #timer-block:-ms-fullscreen { background-color: var(--bg-primary); }

        h1, h2, h3, label, span, p, div { color: inherit; transition: color 0.3s ease; }
        h1 span { color: var(--text-title); }
        #currentRound, #timeDescription { color: var(--text-secondary); }
        #breakIndicator { color: #f97316; }
        html.dark #breakIndicator { color: #fb923c; }
        #timeDisplay { color: var(--text-primary); }

        .reminder-helper-text {
            display: flex;
            align-items: center;
            gap: 0.3rem;
            color: var(--text-secondary);
            transition: color 0.3s ease;
        }
        .reminder-helper-text i {
            font-size: 0.9em;
        }

    </style>
</head>
<body>
    <div class="content container mx-auto px-4 py-8 max-w-5xl relative">
        <button id="mainDarkModeToggle" title="切換顏色模式">
             <i id="mainDarkModeIcon" class="fas fa-moon text-xl"></i>
        </button>

        <header class="text-center mb-8">
             <h1 class="text-4xl font-bold mb-2 flex items-center justify-center">
                 <i class="fa-solid fa-hourglass-half mr-3 text-blue-600"></i>
                 <span>佇註解輪流站計時系統</span>
             </h1>
            <p class="text-lg" style="color: var(--text-secondary);">時間神管理，效率神提升</p>
        </header>

        <div id="notification" class="hidden fixed top-4 left-1/2 transform -translate-x-1/2 px-6 py-3 rounded-lg shadow-lg notification z-50 max-w-md text-center">
            <p class="font-medium text-lg"></p>
        </div>

        <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">
            <!-- Left: Settings Panel -->
            <div class="card rounded-xl shadow-lg p-6 order-2 lg:order-1">
                <h2 class="text-2xl font-bold mb-4 flex items-center">
                     <i class="fa-solid fa-gear mr-2" style="color: var(--text-secondary);"></i>
                     <span>時間設定</span>
                </h2>

                <div class="mb-6">
                    <label class="block mb-2 font-medium settings-label">
                        <i class="fa-solid fa-comments"></i>
                        <span>每輪討論時間</span>
                    </label>
                    <div class="time-input">
                        <div>
                            <input type="number" id="discussionMinutes" value="5" min="0" class="styled-input">
                            <label for="discussionMinutes" class="time-input-label">分鐘</label>
                        </div>
                        <div>
                            <input type="number" id="discussionSeconds" value="0" min="0" max="59" class="styled-input">
                            <label for="discussionSeconds" class="time-input-label">秒鐘</label>
                        </div>
                    </div>
                </div>

                <div class="mb-6">
                    <label class="block mb-2 font-medium settings-label">
                        <i class="fa-solid fa-bell"></i>
                        <span>輪桌提醒時間</span>
                    </label>
                    <div class="time-input">
                        <div>
                            <input type="number" id="reminderMinutes" value="0" min="0" class="styled-input">
                            <label for="reminderMinutes" class="time-input-label">分鐘</label>
                        </div>
                        <div>
                            <input type="number" id="reminderSeconds" value="30" min="0" max="59" class="styled-input">
                            <label for="reminderSeconds" class="time-input-label">秒鐘</label>
                        </div>
                    </div>
                    <p class="text-sm mt-1 reminder-helper-text">
                         <i class="fa-solid fa-circle-info"></i>
                         <span>提前多久提醒輪換桌次</span>
                    </p>
                </div>

                <div class="mb-6">
                    <label class="block mb-2 font-medium settings-label">
                        <i class="fa-solid fa-repeat"></i>
                        <span>總輪桌次數</span>
                    </label>
                    <div class="flex items-center gap-2">
                        <input type="number" id="totalRounds" value="3" min="1" class="styled-input w-20">
                        <span style="color: var(--text-secondary); font-size: 0.875rem;">輪</span>
                    </div>
                </div>


                <div class="mb-6">
                    <label class="block mb-2 font-medium settings-label">
                        <i class="fa-solid fa-mug-saucer"></i>
                        <span>輪桌間休息時間</span>
                    </label>
                    <div class="time-input">
                        <div>
                            <input type="number" id="breakMinutes" value="0" min="0" class="styled-input">
                            <label for="breakMinutes" class="time-input-label">分鐘</label>
                        </div>
                        <div>
                            <input type="number" id="breakSeconds" value="10" min="0" max="59" class="styled-input">
                            <label for="breakSeconds" class="time-input-label">秒鐘</label>
                        </div>
                    </div>
                </div>

                <div class="mb-6">
                    <div class="flex items-center justify-between font-medium mb-3">
                        <span class="settings-label"><i class="fa-solid fa-music"></i><span>提醒鈴聲</span></span>
                        <label class="sound-switch">
                            <input type="checkbox" id="soundToggle" checked>
                            <span class="sound-slider"></span>
                        </label>
                    </div>
                    <div>
                        <label for="soundType" class="block text-sm mb-1 settings-label" style="color: var(--text-secondary);">
                             <i class="fa-solid fa-sliders"></i>
                             <span>鈴聲類型</span>
                        </label>
                        <select id="soundType" class="w-full styled-input"> <!-- Applied styled-input -->
                            <option value="bell">溫和鈴聲</option>
                            <option value="chime">清脆鈴聲</option>
                            <option value="alert">警示音</option>
                        </select>
                    </div>
                    <button id="testSound" class="mt-2 w-full py-2 px-4 rounded-lg transition btn">
                        <i class="fa-solid fa-volume-high"></i>
                        測試鈴聲
                    </button>
                </div>

                <button id="applySettings" class="w-full btn btn-primary">
                    <i class="fa-solid fa-check"></i>
                    套用設定
                </button>
            </div>

            <!-- Middle: Timer -->
            <div id="timer-block" class="card rounded-xl shadow-lg p-6 flex flex-col items-center order-1 lg:order-2 relative">
                 <div id="timer-top-controls">
                    <button id="fullscreenBtn" title="全螢幕/退出全螢幕">
                        <i id="fullscreenIcon" class="fa-solid fa-expand"></i>
                    </button>
                </div>


                 <h2 class="text-2xl font-bold text-center mb-4 flex items-center">
                     <i class="fa-solid fa-clock mr-2" style="color: var(--text-secondary);"></i>
                     <span id="currentRound">第 1 輪</span>
                     <span id="breakIndicator" class="hidden ml-1">（休息時間）</span>
                 </h2>
                 <p id="statusText" class="text-center mb-4 min-h-[24px]" style="color: var(--text-secondary);">準備開始</p>


                <div class="timer-circle flex items-center justify-center mb-6">
                    <svg width="100%" height="100%" viewbox="0 0 280 280" preserveAspectRatio="xMidYMid meet">
                        <!-- ****** ADDED: Gradient Definition ****** -->
                        <defs>
                            <linearGradient id="progressGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                              <stop offset="0%" style="stop-color:#ef4444;stop-opacity:1" />    <!-- Red -->
                              <stop offset="20%" style="stop-color:#f97316;stop-opacity:1" />   <!-- Orange -->
                              <stop offset="40%" style="stop-color:#eab308;stop-opacity:1" />   <!-- Yellow -->
                              <stop offset="60%" style="stop-color:#22c55e;stop-opacity:1" />   <!-- Green -->
                              <stop offset="80%" style="stop-color:#3b82f6;stop-opacity:1" />   <!-- Blue -->
                              <stop offset="100%" style="stop-color:#8b5cf6;stop-opacity:1" />  <!-- Violet -->
                            </linearGradient>
                        </defs>
                         <!-- ****** END GRADIENT DEFINITION ****** -->
                        <circle id="baseCircle" cx="140" cy="140" r="120" fill="none" stroke-width="16"></circle>
                        <circle id="timerCircle" cx="140" cy="140" r="120" fill="none" stroke-width="16" stroke-linecap="round" pathLength="100"></circle> <!-- Stroke applied via CSS -->
                    </svg>
                    <div class="absolute text-center">
                        <div id="timeDisplay" class="text-5xl font-bold tabular-nums">05:00</div>
                        <div id="timeDescription" class="mt-2">剩餘時間</div>
                    </div>
                </div>

                <!-- Control Buttons -->
                <div class="flex space-x-4 w-full mb-4 max-w-sm">
                    <button id="startPauseBtn" class="flex-1 btn btn-primary">
                        <i id="startPauseIcon" class="fas fa-play"></i>
                        <span id="startPauseBtnText">開始</span>
                    </button>
                    <button id="resetBtn" class="flex-1 btn btn-outline-reset" disabled>
                        <i class="fas fa-rotate-left"></i>
                        重置
                    </button>
                </div>

                <button id="skipBtn" class="w-full btn btn-secondary max-w-sm" disabled>
                    <i class="fas fa-forward-step"></i>
                    跳至下一階段
                </button>
            </div>

            <!-- Right: Round Status -->
            <div class="card rounded-xl shadow-lg p-6 order-3">
                 <h2 class="text-2xl font-bold mb-4 flex items-center">
                     <i class="fa-solid fa-list-check mr-2" style="color: var(--text-secondary);"></i>
                     <span>輪桌進度</span>
                 </h2>

                <div id="roundsContainer" class="space-y-4">
                    <!-- Round cards dynamically generated here -->
                </div>
            </div>
        </div>
    </div>

    <footer class="py-4 text-center mt-8">
        <p>Copyright © Liyuchiutiger Gongminshen</p>
    </footer>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // --- DOM 元素 ---
            const htmlElement = document.documentElement;
            const mainDarkModeToggle = document.getElementById('mainDarkModeToggle');
            const mainDarkModeIcon = document.getElementById('mainDarkModeIcon');
            const timerBlock = document.getElementById('timer-block');
            const fullscreenBtn = document.getElementById('fullscreenBtn');
            const fullscreenIcon = document.getElementById('fullscreenIcon');
            const timeDisplay = document.getElementById('timeDisplay');
            const baseCircle = document.getElementById('baseCircle');
            const timerCircle = document.getElementById('timerCircle');
            const startPauseBtn = document.getElementById('startPauseBtn');
            const startPauseIcon = document.getElementById('startPauseIcon');
            const startPauseBtnText = document.getElementById('startPauseBtnText');
            const resetBtn = document.getElementById('resetBtn');
            const skipBtn = document.getElementById('skipBtn');
            const applySettings = document.getElementById('applySettings');
            const currentRound = document.getElementById('currentRound');
            const breakIndicator = document.getElementById('breakIndicator');
            const statusText = document.getElementById('statusText');
            const roundsContainer = document.getElementById('roundsContainer');
            const notification = document.getElementById('notification');
            const notificationText = notification.querySelector('p');
            const soundToggle = document.getElementById('soundToggle');
            const soundType = document.getElementById('soundType');
            const testSound = document.getElementById('testSound');
            const discussionMinutesInput = document.getElementById('discussionMinutes');
            const discussionSecondsInput = document.getElementById('discussionSeconds');
            const reminderMinutesInput = document.getElementById('reminderMinutes');
            const reminderSecondsInput = document.getElementById('reminderSeconds');
            const totalRoundsInput = document.getElementById('totalRounds');
            const breakMinutesInput = document.getElementById('breakMinutes');
            const breakSecondsInput = document.getElementById('breakSeconds');

            // --- Timer State ---
            let animationFrameId = null;
            let isRunning = false;
            let isPaused = false;
            let isBreak = false;
            let currentRoundNumber = 1;
            let stageStartTime = 0;
            let timePaused = 0;
            let stageDuration = 0;
            let reminderTime = 0;
            let reminderShown = false;
            let notificationTimeout = null;
            let lastDisplayedSeconds = -1;

            // --- Settings ---
            let discussionMinutes = 5;
            let discussionSeconds = 0;
            let reminderMinutes = 0;
            let reminderSeconds = 30;
            let totalRounds = 3;
            let breakMinutes = 0;
            let breakSeconds = 10;

            // --- Web Audio API ---
            let audioContext = null;

            // --- Dark Mode ---
            function applyTheme(theme) {
                const isDark = theme === 'dark';
                htmlElement.classList.toggle('dark', isDark);
                const iconClassAdd = isDark ? 'fa-sun' : 'fa-moon';
                const iconClassRemove = isDark ? 'fa-moon' : 'fa-sun';
                mainDarkModeIcon.classList.add(iconClassAdd);
                mainDarkModeIcon.classList.remove(iconClassRemove);
                const title = isDark ? "切換亮色模式" : "切換暗色模式";
                mainDarkModeToggle.title = title;
            }

            function toggleDarkMode() {
                const currentTheme = htmlElement.classList.contains('dark') ? 'dark' : 'light';
                const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
                applyTheme(newTheme);
                localStorage.setItem('theme', newTheme);
            }

            function initializeTheme() {
                const savedTheme = localStorage.getItem('theme');
                const systemPrefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
                let currentTheme = savedTheme || (systemPrefersDark ? 'dark' : 'light');
                applyTheme(currentTheme);
            }

            // --- Audio Functions ---
            function initAudio() {
                try {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    if (audioContext.state === 'suspended') {
                        console.warn("AudioContext is suspended. User interaction required.");
                    }
                } catch (e) {
                    console.error('Web Audio API is not supported.', e);
                    soundToggle.disabled = true;
                    testSound.disabled = true;
                    soundType.disabled = true;
                    const soundErrorMsg = document.createElement('p');
                    soundErrorMsg.textContent = '您的瀏覽器不支援音效播放。';
                    soundErrorMsg.className = 'text-xs text-red-500 mt-1';
                    if (htmlElement.classList.contains('dark')) {
                        soundErrorMsg.style.color = '#f87171';
                    }
                    testSound.parentNode.insertBefore(soundErrorMsg, testSound.nextSibling);
                }
            }

             function playSound(type = 'bell', isReminder = false) {
                if (!audioContext || !soundToggle.checked) return;
                if (audioContext.state === 'suspended') {
                    audioContext.resume().catch(err => console.error("AudioContext resume failed:", err));
                }
                if (audioContext.state !== 'running') {
                    console.warn("AudioContext not running, sound playback aborted.");
                    return;
                }

                const freq1 = isReminder ? 660 : 880;
                const freq2 = isReminder ? 880 : 1046.50;
                const duration = isReminder ? 0.8 : 1.5;
                const gainValue = isReminder ? 0.15 : 0.3;
                let oscType = 'sine';
                switch (type) {
                    case 'chime': oscType = 'triangle'; break;
                    case 'alert': oscType = 'sawtooth'; break;
                }
                const now = audioContext.currentTime;

                try {
                    const osc1 = audioContext.createOscillator();
                    const gain1 = audioContext.createGain();
                    osc1.connect(gain1);
                    gain1.connect(audioContext.destination);
                    osc1.type = oscType;
                    osc1.frequency.setValueAtTime(freq1, now);
                    gain1.gain.setValueAtTime(0, now);
                    gain1.gain.linearRampToValueAtTime(gainValue, now + 0.05);
                    gain1.gain.exponentialRampToValueAtTime(0.001, now + duration);
                    osc1.start(now);
                    osc1.stop(now + duration);

                    if (!isReminder || type !== 'alert') {
                         setTimeout(() => {
                            if (!audioContext || audioContext.state !== 'running') return;
                            const now2 = audioContext.currentTime;
                            const osc2 = audioContext.createOscillator();
                            const gain2 = audioContext.createGain();
                            osc2.connect(gain2);
                            gain2.connect(audioContext.destination);
                            osc2.type = oscType;
                            osc2.frequency.setValueAtTime(freq2, now2);
                            gain2.gain.setValueAtTime(0, now2);
                            gain2.gain.linearRampToValueAtTime(gainValue, now2 + 0.05);
                            gain2.gain.exponentialRampToValueAtTime(0.001, now2 + duration);
                            osc2.start(now2);
                            osc2.stop(now2 + duration);
                        }, isReminder ? 250 : 400);
                    }
                } catch (error) {
                    console.error("Error playing sound:", error);
                }
            }

            // --- UI Update Functions ---
            function initializeRoundCards() {
                roundsContainer.innerHTML = '';
                for (let i = 1; i <= totalRounds; i++) {
                    const card = document.createElement('div');
                    card.id = `round-${i}`;
                    card.className = 'table-card p-4 border rounded-lg';
                    const discussionTimeText = formatSettingsTime(discussionMinutes, discussionSeconds);
                    card.innerHTML = `
                        <div class="flex justify-between items-center">
                            <div>
                                <h3 class="font-medium text-lg">第 ${i} 輪討論</h3>
                                <p class="text-sm">${discussionTimeText || '0 秒'}</p>
                            </div>
                            <div class="status-indicator w-3 h-3 rounded-full shrink-0 ml-2"></div>
                        </div>`;
                    card.addEventListener('click', handleCardClick);
                    roundsContainer.appendChild(card);

                    const breakTimeTotal = breakMinutes * 60 + breakSeconds;
                    if (breakTimeTotal > 0 && i < totalRounds) {
                        const breakCard = document.createElement('div');
                        breakCard.id = `break-${i}`;
                        breakCard.className = 'table-card p-4 border rounded-lg';
                        const breakTimeText = formatSettingsTime(breakMinutes, breakSeconds);
                        breakCard.innerHTML = `
                            <div class="flex justify-between items-center">
                                <div>
                                    <h3 class="font-medium text-lg">休息時間</h3>
                                    <p class="text-sm">${breakTimeText || '0 秒'}</p>
                                </div>
                                <div class="status-indicator w-3 h-3 rounded-full shrink-0 ml-2"></div>
                            </div>`;
                        breakCard.addEventListener('click', handleCardClick);
                        roundsContainer.appendChild(breakCard);
                    }
                }
                updateRoundCards();
            }

            function updateRoundCards() {
                // Reset all cards visually first
                document.querySelectorAll('.table-card').forEach(card => {
                    card.classList.remove('active-round', 'active-break', 'completed', 'animate-pulse');
                    card.style.cursor = 'pointer'; // Assume clickable initially
                    const indicator = card.querySelector('.status-indicator');
                    if (indicator) indicator.classList.remove('animate-pulse');
                });

                // Mark stages *before* the current one as completed
                for (let i = 1; i < currentRoundNumber; i++) {
                    markCardCompleted(document.getElementById(`round-${i}`));
                    if (i < totalRounds) {
                         markCardCompleted(document.getElementById(`break-${i}`));
                    }
                }
                 // If current stage is a discussion, mark the break *before* it (if any) as completed
                 if (!isBreak && currentRoundNumber > 1) {
                     markCardCompleted(document.getElementById(`break-${currentRoundNumber - 1}`));
                 }
                // If current stage is a break, mark the round *before* it as completed
                 if (isBreak) { // currentRoundNumber refers to the round *before* the break
                      markCardCompleted(document.getElementById(`round-${currentRoundNumber}`));
                 }


                // Highlight the current stage (unless the whole process is finished)
                const isFinished = currentRoundNumber > totalRounds && !isBreak;
                if (!isFinished && (isRunning || isPaused)) {
                    const currentCardId = isBreak ? `break-${currentRoundNumber}` : `round-${currentRoundNumber}`;
                    const currentCard = document.getElementById(currentCardId);
                    if (currentCard) { // currentCard should exist and not be marked completed yet
                        currentCard.classList.remove('completed'); // Ensure it's not styled as completed
                        currentCard.classList.add(isBreak ? 'active-break' : 'active-round');
                        currentCard.style.cursor = 'default'; // Current card isn't clickable to jump to itself
                        if (isRunning) {
                            currentCard.classList.add('animate-pulse');
                            const indicator = currentCard.querySelector('.status-indicator');
                            if (indicator) indicator.classList.add('animate-pulse');
                        }
                    }
                } else if (isFinished) {
                     // Ensure final round and preceding break (if any) are marked completed
                      markCardCompleted(document.getElementById(`round-${totalRounds}`));
                      if (totalRounds > 1) {
                          markCardCompleted(document.getElementById(`break-${totalRounds - 1}`));
                      }
                }

                 // After logic, ensure all truly completed cards have 'not-allowed' cursor
                 document.querySelectorAll('.table-card.completed').forEach(card => {
                    card.style.cursor = 'not-allowed';
                 });
            }


            function markCardCompleted(cardElement) {
                 if (!cardElement) return;
                 cardElement.classList.remove('active-round', 'active-break', 'animate-pulse');
                 cardElement.classList.add('completed');
                 cardElement.style.cursor = 'not-allowed'; // Set cursor explicitly when marking complete
                 const indicator = cardElement.querySelector('.status-indicator');
                  if (indicator) indicator.classList.remove('animate-pulse');
            }

            function formatSettingsTime(minutes, seconds) {
                let parts = [];
                if (minutes > 0) parts.push(`${minutes} 分鐘`);
                if (seconds > 0) parts.push(`${seconds} 秒`);
                return parts.join(' ') || null;
            }

            function formatTimerDisplay(seconds) {
                const displaySeconds = Math.max(0, Math.ceil(seconds));
                const mins = Math.floor(displaySeconds / 60);
                const secs = displaySeconds % 60;
                return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            }

            // ****** MODIFIED: updateTimerVisuals - Removed color logic ******
            function updateTimerVisuals(preciseTimeRemaining) {
                const displaySeconds = Math.max(0, preciseTimeRemaining);

                // Update text display only when the whole second changes
                const currentWholeSeconds = Math.ceil(displaySeconds);
                if (currentWholeSeconds !== lastDisplayedSeconds) {
                     timeDisplay.textContent = formatTimerDisplay(displaySeconds);
                     lastDisplayedSeconds = currentWholeSeconds;
                      // Update page title
                      let titleStage = isBreak ? `休息 (${currentRoundNumber}/${totalRounds})` : `第 ${currentRoundNumber} 輪`;
                      const isFinished = currentRoundNumber > totalRounds && !isBreak;
                      if (isFinished) titleStage = "已完成";
                      document.title = `${formatTimerDisplay(displaySeconds)} - ${titleStage} | 輪流站計時`;
                }

                // Update circle progress (stroke-dashoffset)
                const percentage = stageDuration > 0 ? ((stageDuration - displaySeconds) / stageDuration) * 100 : 0;
                const clampedPercentage = Math.max(0, Math.min(100, percentage));
                timerCircle.style.strokeDashoffset = 100 - clampedPercentage;

                // Color logic is removed as the gradient is static SVG
            }
             // ****** END MODIFICATION ******

             function updateButtonStates() {
                 const isFinished = currentRoundNumber > totalRounds && !isBreak;
                 const canReset = isRunning || isPaused || isFinished || (currentRoundNumber === 1 && !isBreak && !isRunning && !isPaused) || (isBreak && !isRunning && !isPaused);
                 // Skip button logic remains the same
                 const canSkip = (isRunning || isPaused) && !isFinished;

                 resetBtn.disabled = !canReset;
                 skipBtn.disabled = !canSkip;

                 startPauseBtn.disabled = false;
                 startPauseBtn.classList.remove('btn-primary', 'btn-outline-pause');

                 if (isFinished) {
                     startPauseBtnText.textContent = '重新開始';
                     startPauseIcon.className = 'fas fa-rotate-right';
                     startPauseBtn.classList.add('btn-primary');
                 } else if (isRunning && !isPaused) {
                     startPauseBtnText.textContent = '暫停';
                     startPauseIcon.className = 'fas fa-pause';
                     startPauseBtn.classList.add('btn-outline-pause');
                 } else if (isPaused) {
                     startPauseBtnText.textContent = '繼續';
                     startPauseIcon.className = 'fas fa-play';
                     startPauseBtn.classList.add('btn-primary');
                 } else { // Ready to start
                     startPauseBtnText.textContent = '開始';
                     startPauseIcon.className = 'fas fa-play';
                     startPauseBtn.classList.add('btn-primary');
                 }
            }

            function showNotification(message, type = 'info') {
                if (notificationTimeout) clearTimeout(notificationTimeout);

                notificationText.textContent = message;
                notification.classList.remove('hidden', 'bg-blue-600', 'bg-orange-500', 'bg-green-600');

                let bgColor = 'bg-blue-600';
                let shouldPlaySound = false;
                let isReminderSound = false;

                if (type === 'warning') {
                     bgColor = 'bg-orange-500';
                     shouldPlaySound = true;
                     isReminderSound = true;
                } else if (type === 'success') {
                     bgColor = 'bg-green-600';
                     shouldPlaySound = true;
                } else {
                    if (message.includes('開始') || message.includes('結束') || message.includes('輪討論') || message.includes('跳轉') || message.includes('重新開始') || message.includes('完成') || message.includes('休息時間')) {
                         shouldPlaySound = true;
                    }
                }

                if(shouldPlaySound) {
                    if (audioContext && audioContext.state === 'suspended') {
                        audioContext.resume().then(() => {
                             playSound(soundType.value, isReminderSound);
                        }).catch(err => console.error("Notification sound resume failed:", err));
                    } else if (audioContext && audioContext.state === 'running') {
                         playSound(soundType.value, isReminderSound);
                    }
                }

                notification.classList.add(bgColor);
                notification.style.animation = 'none';
                void notification.offsetWidth;
                notification.style.animation = '';
                notification.classList.add('notification');

                 notificationTimeout = setTimeout(() => {
                    notification.classList.add('hidden');
                    notificationTimeout = null;
                }, 5000);
            }

            // --- Core Timer Logic ---

            function proceedToNextStage() {
                 console.log(`Proceeding from: Round ${currentRoundNumber}, Is Break: ${isBreak}`);
                 const currentCardId = isBreak ? `break-${currentRoundNumber}` : `round-${currentRoundNumber}`;
                 markCardCompleted(document.getElementById(currentCardId));

                 if (isBreak) {
                    isBreak = false;
                    currentRoundNumber++;
                    if (currentRoundNumber > totalRounds) {
                        showNotification('所有輪桌討論已結束！', 'success');
                        resetTimer(true);
                        console.log("Process ended (after final break).");
                        return false;
                    } else {
                        showNotification(`第 ${currentRoundNumber} 輪討論即將開始！`);
                        breakIndicator.classList.add('hidden');
                        currentRound.textContent = `第 ${currentRoundNumber} 輪`;
                    }
                } else {
                     const hasBreakTime = breakMinutes * 60 + breakSeconds > 0;
                     if (hasBreakTime && currentRoundNumber < totalRounds) {
                        isBreak = true;
                        showNotification('休息時間即將開始！');
                        breakIndicator.classList.remove('hidden');
                    } else {
                         isBreak = false;
                         currentRoundNumber++;
                         if (currentRoundNumber > totalRounds) {
                             showNotification('所有輪桌討論已結束！', 'success');
                             resetTimer(true);
                             console.log("Process ended (after final round, no break).");
                             return false;
                         } else {
                            showNotification(`第 ${currentRoundNumber} 輪討論即將開始！`);
                            breakIndicator.classList.add('hidden');
                            currentRound.textContent = `第 ${currentRoundNumber} 輪`;
                         }
                    }
                }
                console.log(`Transitioned to: Round ${currentRoundNumber}, Is Break: ${isBreak}`);
                return true;
            }

            function timerLoop(timestamp) {
                 if (!isRunning || isPaused) return;
                 if (stageStartTime === 0) stageStartTime = timestamp;

                 const elapsedMs = timestamp - stageStartTime;
                 const elapsedSeconds = elapsedMs / 1000;
                 let preciseTimeRemaining = Math.max(0, stageDuration - elapsedSeconds);

                 updateTimerVisuals(preciseTimeRemaining);

                 if (!isBreak && !reminderShown && reminderTime > 0 && preciseTimeRemaining <= reminderTime) {
                     const reminderTimeText = formatSettingsTime(reminderMinutes, reminderSeconds);
                     showNotification(`剩下 ${reminderTimeText}，請準備輪換！`, 'warning');
                     reminderShown = true;
                     // Maybe add a visual pulse/glow effect here instead of color change?
                     // e.g., timerCircle.classList.add('reminder-pulse');
                 } else if (preciseTimeRemaining > reminderTime) {
                     // Remove reminder effect if time goes back up (e.g., after jumping)
                     // e.g., timerCircle.classList.remove('reminder-pulse');
                 }


                 if (preciseTimeRemaining < 0.05) { // Time's up
                     console.log("Stage time ended.");
                     isRunning = false;
                     if (animationFrameId) {
                        cancelAnimationFrame(animationFrameId);
                        animationFrameId = null;
                     }
                     stageStartTime = 0;
                     // timerCircle.classList.remove('reminder-pulse'); // Clear reminder effect

                     updateTimerVisuals(0);
                     playSound(soundType.value);

                     const canContinue = proceedToNextStage();

                     if (canContinue) {
                         console.log("Preparing auto-start for next stage...");
                         setTimeout(() => {
                             console.log("Attempting auto-start...");
                             const isFinishedCheck = currentRoundNumber > totalRounds && !isBreak;
                             if (!isPaused && !isFinishedCheck && !isRunning) {
                                 console.log("Auto-starting next stage.");
                                 startTimer();
                             } else {
                                 console.log("Timer state changed during transition, auto-start cancelled.");
                                 if(isPaused) {
                                    stageDuration = isBreak ? (breakMinutes * 60 + breakSeconds) : (discussionMinutes * 60 + discussionSeconds);
                                    updateTimerVisuals(stageDuration);
                                    statusText.textContent = `準備開始 ${isBreak ? '休息' : `第 ${currentRoundNumber} 輪`} (已暫停)`;
                                    updateButtonStates();
                                    updateRoundCards();
                                 }
                             }
                         }, 1500);
                     } else {
                         console.log("Process has reached the end.");
                         document.title = '輪流站計時系統 - 已完成';
                     }
                 } else {
                     animationFrameId = requestAnimationFrame(timerLoop);
                 }
             }


            function startTimer() {
                 const isFinished = currentRoundNumber > totalRounds && !isBreak;
                 if (isFinished) {
                     console.log("Restarting from finished state.");
                     resetTimer(false);
                      setTimeout(startTimer, 50);
                     return;
                 }

                 if (isRunning) {
                     console.warn("Timer already running.");
                     return;
                 }

                 if (isPaused) {
                     console.log("Resuming from paused state.");
                     isPaused = false;
                     isRunning = true;
                     const pauseDurationMs = performance.now() - timePaused;
                     stageStartTime += pauseDurationMs;
                     statusText.textContent = isBreak ? '休息時間' : '討論進行中';
                     updateButtonStates();
                     updateRoundCards();
                     animationFrameId = requestAnimationFrame(timerLoop);
                     return;
                 }

                 console.log(`Starting new stage: Round ${currentRoundNumber}, Is Break: ${isBreak}`);

                 if (isBreak) {
                     stageDuration = breakMinutes * 60 + breakSeconds;
                     reminderTime = 0;
                 } else {
                     stageDuration = discussionMinutes * 60 + discussionSeconds;
                     reminderTime = reminderMinutes * 60 + reminderSeconds;
                 }

                 if (stageDuration <= 0) {
                     console.warn(`Stage duration is ${stageDuration}s. Skipping.`);
                     showNotification(`時間設為 0，跳過 ${isBreak ? '休息' : `第 ${currentRoundNumber} 輪`}`, 'warning');
                     updateTimerVisuals(0);
                      const zeroCardId = isBreak ? `break-${currentRoundNumber}` : `round-${currentRoundNumber}`;
                      markCardCompleted(document.getElementById(zeroCardId));
                     const canContinue = proceedToNextStage();
                     if (canContinue) {
                         stageDuration = isBreak ? (breakMinutes * 60 + breakSeconds) : (discussionMinutes * 60 + discussionSeconds);
                         statusText.textContent = `準備開始 ${isBreak ? '休息' : `第 ${currentRoundNumber} 輪`}`;
                         updateTimerVisuals(stageDuration);
                         updateRoundCards();
                         updateButtonStates();
                          setTimeout(() => {
                             console.log("Auto-starting after skipping zero-time stage.");
                              const isFinishedCheck = currentRoundNumber > totalRounds && !isBreak;
                             if (!isPaused && !isFinishedCheck && !isRunning) startTimer();
                          }, 50);
                     } else {
                         resetTimer(true);
                         updateButtonStates();
                     }
                     return;
                 }

                 reminderShown = false;
                 lastDisplayedSeconds = -1;
                 stageStartTime = performance.now();
                 isRunning = true;
                 isPaused = false;

                 statusText.textContent = isBreak ? '休息時間' : '討論進行中';
                 currentRound.textContent = `第 ${currentRoundNumber} 輪`;
                 breakIndicator.classList.toggle('hidden', !isBreak);
                 updateButtonStates();
                 updateRoundCards(); // This will remove 'completed' if jumping back
                 updateTimerVisuals(stageDuration);

                 animationFrameId = requestAnimationFrame(timerLoop);
            }

            function pauseTimer() {
                if (!isRunning || isPaused) return;
                console.log("Pausing timer.");
                isRunning = false;
                isPaused = true;
                timePaused = performance.now();
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                }
                statusText.textContent += ' (已暫停)';
                updateRoundCards(); // Remove pulse
                updateButtonStates();
            }

             function resetTimer(completed = false) {
                console.log(`Resetting timer. Completed: ${completed}`);
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                }
                isRunning = false;
                isPaused = false;
                stageStartTime = 0;

                const wasFinished = currentRoundNumber > totalRounds && !isBreak;

                 if (completed && wasFinished) {
                     statusText.textContent = '所有討論已結束';
                     currentRound.textContent = `共 ${totalRounds} 輪`;
                     breakIndicator.classList.add('hidden');
                     stageDuration = 0;
                     updateRoundCards();
                 } else {
                     currentRoundNumber = 1;
                     isBreak = false;
                     breakIndicator.classList.add('hidden');
                     statusText.textContent = '準備開始';
                     currentRound.textContent = `第 ${currentRoundNumber} 輪`;
                     stageDuration = discussionMinutes * 60 + discussionSeconds;
                      if (!completed || !wasFinished) {
                         initializeRoundCards(); // Full rebuild if needed
                      } else {
                          updateRoundCards(); // Just update highlighting
                      }
                 }

                 reminderShown = false;
                 lastDisplayedSeconds = -1;

                 updateTimerVisuals(stageDuration);
                 // Reset progress bar to empty
                 timerCircle.style.strokeDashoffset = 100;

                 updateButtonStates();
                 document.title = completed ? '佇註解輪流站計時系統 - 已完成' : '佇註解輪流站計時系統';
             }

            function skipToNextStage() {
                 if ((!isRunning && !isPaused) || (currentRoundNumber > totalRounds && !isBreak)) return;

                 console.log("Manual skip to next stage.");
                 if (animationFrameId) {
                     cancelAnimationFrame(animationFrameId);
                     animationFrameId = null;
                 }
                 isRunning = false;
                 isPaused = false;
                 stageStartTime = 0;

                 const skippedCardId = isBreak ? `break-${currentRoundNumber}` : `round-${currentRoundNumber}`;
                 markCardCompleted(document.getElementById(skippedCardId));

                 const canContinue = proceedToNextStage();

                 if (canContinue) {
                     stageDuration = isBreak ? (breakMinutes * 60 + breakSeconds) : (discussionMinutes * 60 + discussionSeconds);
                     statusText.textContent = `準備開始 ${isBreak ? '休息' : `第 ${currentRoundNumber} 輪`}`;
                     breakIndicator.classList.toggle('hidden', !isBreak);
                     updateTimerVisuals(stageDuration);
                     updateRoundCards(); // Update highlighting for the *new* ready stage
                     updateButtonStates(); // Set to "Start"
                     timerCircle.style.strokeDashoffset = 100; // Reset progress
                     showNotification(`已跳至下一階段，準備開始 ${isBreak ? '休息' : `第 ${currentRoundNumber} 輪`}`, 'info');
                 } else {
                     resetTimer(true); // Reached end
                 }
            }

            // ****** MODIFIED: handleCardClick - Allow jumping to completed ******
            function handleCardClick(event) {
                const clickedCard = event.currentTarget;

                // 1. Prevent jump if timer is actively running
                if (isRunning) {
                    showNotification('請先暫停計時器才能跳轉輪次', 'warning');
                    return;
                }

                // 2. Parse target stage (REMOVED completed check)
                const cardId = clickedCard.id;
                let targetRound, targetIsBreak;

                console.log(`Card clicked: ${cardId}`);

                if (cardId.startsWith('round-')) {
                    targetRound = parseInt(cardId.split('-')[1]);
                    targetIsBreak = false;
                } else if (cardId.startsWith('break-')) {
                    targetRound = parseInt(cardId.split('-')[1]);
                    targetIsBreak = true;
                } else {
                    console.warn("Invalid card ID clicked:", cardId);
                    return;
                }

                 if (isNaN(targetRound) || targetRound < 1 || targetRound > totalRounds || (targetIsBreak && targetRound >= totalRounds)) {
                     console.warn("Invalid jump target parsed.");
                     return;
                 }

                // 3. Prevent jump if clicking the *current paused* stage
                if (isPaused && targetRound === currentRoundNumber && targetIsBreak === isBreak) {
                     console.log("Already at the target paused stage.");
                     showNotification('已處於您點選的階段 (已暫停)', 'info');
                     return;
                 }

                console.log(`Jumping to: Round ${targetRound}, Is Break: ${targetIsBreak}`);

                // Stop timer & reset flags
                if (animationFrameId) cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
                isRunning = false;
                isPaused = false;
                stageStartTime = 0;
                reminderShown = false; // Reset reminder flag on jump

                // Update global state
                currentRoundNumber = targetRound;
                isBreak = targetIsBreak;

                showNotification(`已跳轉至 ${isBreak ? `第 ${currentRoundNumber} 輪後休息` : `第 ${currentRoundNumber} 輪討論`}`, 'info');

                // Set UI to 'ready' state for the target stage
                stageDuration = isBreak ? (breakMinutes * 60 + breakSeconds) : (discussionMinutes * 60 + discussionSeconds);
                reminderTime = isBreak ? 0 : (reminderMinutes * 60 + reminderSeconds); // Reset reminder threshold
                statusText.textContent = `準備開始 ${isBreak ? '休息' : `第 ${currentRoundNumber} 輪`}`;
                currentRound.textContent = `第 ${currentRoundNumber} 輪`;
                breakIndicator.classList.toggle('hidden', !isBreak);

                updateTimerVisuals(stageDuration); // Show full time
                updateRoundCards(); // CRITICAL: This will now mark previous stages complete AND un-complete the target stage for highlighting
                updateButtonStates(); // Set to "Start"
                timerCircle.style.strokeDashoffset = 100; // Reset progress bar visually
            }
            // ****** END MODIFICATION ******


            function applyNewSettings() {
                 console.log("Applying new settings...");
                 if (animationFrameId) cancelAnimationFrame(animationFrameId);
                 animationFrameId = null;
                 isRunning = false;
                 isPaused = false;
                 stageStartTime = 0;

                discussionMinutes = Math.max(0, parseInt(discussionMinutesInput.value) || 0);
                discussionSeconds = Math.max(0, Math.min(59, parseInt(discussionSecondsInput.value) || 0));
                reminderMinutes = Math.max(0, parseInt(reminderMinutesInput.value) || 0);
                reminderSeconds = Math.max(0, Math.min(59, parseInt(reminderSecondsInput.value) || 0));
                totalRounds = Math.max(1, parseInt(totalRoundsInput.value) || 1);
                breakMinutes = Math.max(0, parseInt(breakMinutesInput.value) || 0);
                breakSeconds = Math.max(0, Math.min(59, parseInt(breakSecondsInput.value) || 0));

                 discussionMinutesInput.value = discussionMinutes;
                 discussionSecondsInput.value = discussionSeconds;
                 reminderMinutesInput.value = reminderMinutes;
                 reminderSecondsInput.value = reminderSeconds;
                 totalRoundsInput.value = totalRounds;
                 breakMinutesInput.value = breakMinutes;
                 breakSecondsInput.value = breakSeconds;

                 let warnings = [];
                 const discussionTotalSeconds = discussionMinutes * 60 + discussionSeconds;
                 const reminderTotalSeconds = reminderMinutes * 60 + reminderSeconds;

                 if (reminderTotalSeconds >= discussionTotalSeconds && discussionTotalSeconds > 0) {
                     let newReminderTotal = Math.max(0, discussionTotalSeconds - 10);
                     reminderMinutes = Math.floor(newReminderTotal / 60);
                     reminderSeconds = newReminderTotal % 60;
                     reminderMinutesInput.value = reminderMinutes; reminderSecondsInput.value = reminderSeconds;
                     warnings.push("提醒時間已調整為小於討論時間。");
                 } else if (discussionTotalSeconds <= 0 && reminderTotalSeconds > 0) {
                      reminderMinutes = 0; reminderSeconds = 0;
                      reminderMinutesInput.value = reminderMinutes; reminderSecondsInput.value = reminderSeconds;
                      warnings.push("討論時間為0，提醒時間已設為0。")
                 }

                 initializeRoundCards();
                 resetTimer(false);

                 if (warnings.length > 0) {
                    showNotification(warnings.join(' '), 'warning');
                 } else {
                    showNotification('設定已套用', 'info');
                 }
                 console.log("Settings applied:", { discussionMinutes, discussionSeconds, reminderMinutes, reminderSeconds, totalRounds, breakMinutes, breakSeconds });
            }

            // --- Fullscreen Logic ---
            function toggleFullscreen() {
                if (!document.fullscreenElement) {
                    timerBlock.requestFullscreen().catch(err => {
                        console.error(`Fullscreen request failed: ${err.message} (${err.name})`);
                        alert(`無法進入全螢幕模式。\n錯誤訊息: ${err.message}`);
                    });
                } else {
                    if (document.exitFullscreen) {
                        document.exitFullscreen();
                    }
                }
            }

            function updateFullscreenButton() {
                 if (document.fullscreenElement === timerBlock) {
                    fullscreenIcon.classList.replace('fa-expand', 'fa-compress');
                    fullscreenBtn.title = "退出全螢幕";
                 } else {
                    fullscreenIcon.classList.replace('fa-compress', 'fa-expand');
                    fullscreenBtn.title = "全螢幕";
                 }
            }


            // --- Event Listeners ---
            startPauseBtn.addEventListener('click', () => {
                if (audioContext && audioContext.state === 'suspended') {
                    audioContext.resume().then(() => console.log("AudioContext resumed on Start/Pause click."));
                }
                const isFinished = currentRoundNumber > totalRounds && !isBreak;
                if (isFinished) startTimer();
                else if (isRunning) pauseTimer();
                else startTimer();
            });
            resetBtn.addEventListener('click', () => resetTimer(false));
            skipBtn.addEventListener('click', skipToNextStage);
            applySettings.addEventListener('click', applyNewSettings);

            testSound.addEventListener('click', () => {
                if (audioContext && audioContext.state === 'suspended') {
                    audioContext.resume().then(() => {
                        console.log("AudioContext resumed by test button.");
                        playSound(soundType.value);
                    }).catch(err => console.error("Test sound resume failed:", err));
                } else if (audioContext && audioContext.state === 'running') {
                    playSound(soundType.value);
                } else if (!audioContext) {
                    console.warn("AudioContext not initialized.")
                } else {
                     console.warn(`Cannot play test sound, AudioContext state: ${audioContext.state}`);
                }
            });

            fullscreenBtn.addEventListener('click', toggleFullscreen);
            mainDarkModeToggle.addEventListener('click', toggleDarkMode);

            document.addEventListener('fullscreenchange', updateFullscreenButton);

             // Input validation
             [discussionSecondsInput, reminderSecondsInput, breakSecondsInput].forEach(input => {
                input.addEventListener('input', () => {
                    let val = parseInt(input.value) || 0;
                    input.value = Math.max(0, Math.min(59, val));
                 });
             });
             [discussionMinutesInput, reminderMinutesInput, breakMinutesInput].forEach(input => {
                 input.addEventListener('input', () => {
                    let val = parseInt(input.value) || 0;
                    input.value = Math.max(0, val);
                 });
             });
              totalRoundsInput.addEventListener('input', () => {
                    let val = parseInt(totalRoundsInput.value) || 1;
                    totalRoundsInput.value = Math.max(1, val);
              });

            // Keyboard shortcuts
            document.addEventListener('keydown', function(e) {
                if (e.target.matches('input, select, textarea')) return;

                switch (e.code) {
                    case 'Space':
                        e.preventDefault();
                        if (!startPauseBtn.disabled) startPauseBtn.click();
                        break;
                    case 'KeyR':
                         e.preventDefault();
                         if (!resetBtn.disabled) resetBtn.click();
                         break;
                    case 'KeyN':
                         e.preventDefault();
                         if (!skipBtn.disabled) skipBtn.click();
                         break;
                     case 'KeyF':
                          e.preventDefault();
                          fullscreenBtn.click();
                          break;
                    case 'KeyD':
                         e.preventDefault();
                         mainDarkModeToggle.click();
                         break;
                }
            });

            // --- Initialization ---
            initializeTheme();
            initAudio();
            applyNewSettings();
            updateFullscreenButton();

        });
    </script>
</body>
</html>